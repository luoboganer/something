# 核心问题是搜索问题
1. 确定目标 goal
2. 确定搜索空间 search space
3. 选择搜索算法 search algorithm
> Note. 搜索算法往往和具体的数据结构链接在一起（algorithm ~ data structure）

# 具体的搜索算法
## 1. 枚举法
    a. 线性搜索
    b. 随机全排列index枚举

## 2. 二分搜索   $log(n)$
    a. 折半查找的核心思想是根据数据有序的特性每次过滤一半的数据，从而实现对数时间复杂度
    b. mid=math.round(lowIndex+highIndex)，这里向上取整或向下取整

## 3. 回溯思想：到退一步重新进行下一次搜索

## 4. DFS与BFS
    a. Depth First Search 深度优先搜索，栈（stack）实现
    b. Breadth First Search 广度优先搜索，队列（rear）实现
    c. BFS与DFS结合的迭代加深搜索，即限制最大深度的DFS，防止自己陷入最坏的情况

## 5. 并行搜索：分割 -> 搜索 -> 合并 
    前提是分割与合并的带来的额外开销远小于搜素开销，特别适合可以多路并行的任务

## 6. 索引index 与 逆向索引 inverted index
    Eg. 一本书用目录作为索引，然后在书末列出书中出现频率较高的人名、地名等都在哪些页码出现过，即是逆向索引

## 7. 二叉搜索树
    ## 完全平衡二叉树

    ## trie树（前缀树），用于字符串的查找

    a. 建造二叉树的方法
    b. 加入节点造成的二叉树不平衡问题导致的搜索效率下降
    c. 区间搜索的应用与剪枝搜索方法

>>> 在多次搜索过程中平均二叉树的建造于维护成本的**时间摊销**思想 

## 8. 优先队列
    ## 给队列中的元素添加优先级评分
    a. 优先级的评判标准
    b. 优先队列的实现：堆

> 堆：  
    a. 大顶堆：根节点值大于所有子节点  
    b. 小顶堆：根节点值小于所有子节点

    ##  堆的主要用途（大顶堆为例）：
        a. 找到最大值
        b. 删除最大值
        c. 添加任意值

    ## 堆可以用数组实现，类似完全二叉树的数组实现
        a. 节点i的左右子节点分别在2*i+1、2*i+2
        b. 任何节点k的父节点在math.ceil(k/2)[向下取整] 

## 9. 启发式算法：依靠经验的随机性搜索，但是往往很有效

## 10. 高效算法的关键在于对信息的有效获取与利用
    · The key is information.